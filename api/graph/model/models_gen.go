// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"git.sr.ht/~sircmpwn/core-go/model"
)

type Blob interface {
	IsBlob()
}

type Entity interface {
	IsEntity()
}

type WebhookPayload interface {
	IsWebhookPayload()
}

type WebhookSubscription interface {
	IsWebhookSubscription()
}

// A cursor for enumerating access control list entries
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type ACLCursor struct {
	Results []*ACL        `json:"results"`
	Cursor  *model.Cursor `json:"cursor"`
}

// A cursor for enumerating artifacts
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type ArtifactCursor struct {
	Results []*Artifact   `json:"results"`
	Cursor  *model.Cursor `json:"cursor"`
}

// A cursor for enumerating commits
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type CommitCursor struct {
	Results []*Commit     `json:"results"`
	Cursor  *model.Cursor `json:"cursor"`
}

// Describes the status of optional features
type Features struct {
	Artifacts bool `json:"artifacts"`
}

type OAuthClient struct {
	UUID string `json:"uuid"`
}

// A cursor for enumerating a list of references
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type ReferenceCursor struct {
	Results []*Reference  `json:"results"`
	Cursor  *model.Cursor `json:"cursor"`
}

// A cursor for enumerating a list of repositories
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type RepositoryCursor struct {
	Results []*Repository `json:"results"`
	Cursor  *model.Cursor `json:"cursor"`
}

type RepositoryEvent struct {
	UUID       string       `json:"uuid"`
	Event      WebhookEvent `json:"event"`
	Date       time.Time    `json:"date"`
	Repository *Repository  `json:"repository"`
}

func (RepositoryEvent) IsWebhookPayload() {}

// Instance specific settings
type Settings struct {
	SSHUser string `json:"sshUser"`
}

type Signature struct {
	Name  string    `json:"name"`
	Email string    `json:"email"`
	Time  time.Time `json:"time"`
}

type Tag struct {
	Type    ObjectType `json:"type"`
	ID      string     `json:"id"`
	ShortID string     `json:"shortId"`
	Raw     string     `json:"raw"`
	Target  Object     `json:"target"`
	Name    string     `json:"name"`
	Tagger  *Signature `json:"tagger"`
	Message *string    `json:"message"`
}

func (Tag) IsObject() {}

// A cursor for enumerating tree entries
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type TreeEntryCursor struct {
	Results []*TreeEntry  `json:"results"`
	Cursor  *model.Cursor `json:"cursor"`
}

type UserWebhookInput struct {
	URL    string         `json:"url"`
	Events []WebhookEvent `json:"events"`
	Query  string         `json:"query"`
}

type UserWebhookSubscription struct {
	ID         int                    `json:"id"`
	Events     []WebhookEvent         `json:"events"`
	Query      string                 `json:"query"`
	URL        string                 `json:"url"`
	Client     *OAuthClient           `json:"client"`
	Deliveries *WebhookDeliveryCursor `json:"deliveries"`
	Sample     string                 `json:"sample"`
}

func (UserWebhookSubscription) IsWebhookSubscription() {}

type Version struct {
	Major int `json:"major"`
	Minor int `json:"minor"`
	Patch int `json:"patch"`
	// If this API version is scheduled for deprecation, this is the date on which
	// it will stop working; or null if this API version is not scheduled for
	// deprecation.
	DeprecationDate *time.Time `json:"deprecationDate"`
	// Optional features
	Features *Features `json:"features"`
	// Config settings
	Settings *Settings `json:"settings"`
}

type WebhookDelivery struct {
	UUID         string              `json:"uuid"`
	Date         time.Time           `json:"date"`
	Event        WebhookEvent        `json:"event"`
	Subscription WebhookSubscription `json:"subscription"`
	RequestBody  string              `json:"requestBody"`
	// These details are provided only after a response is received from the
	// remote server. If a response is sent whose Content-Type is not text/*, or
	// cannot be decoded as UTF-8, the response body will be null. It will be
	// truncated after 64 KiB.
	ResponseBody    *string `json:"responseBody"`
	ResponseHeaders *string `json:"responseHeaders"`
	ResponseStatus  *int    `json:"responseStatus"`
}

// A cursor for enumerating a list of webhook deliveries
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type WebhookDeliveryCursor struct {
	Results []*WebhookDelivery `json:"results"`
	Cursor  *model.Cursor      `json:"cursor"`
}

// A cursor for enumerating a list of webhook subscriptions
//
// If there are additional results available, the cursor object may be passed
// back into the same endpoint to retrieve another page. If the cursor is null,
// there are no remaining results to return.
type WebhookSubscriptionCursor struct {
	Results []WebhookSubscription `json:"results"`
	Cursor  *model.Cursor         `json:"cursor"`
}

type AccessKind string

const (
	AccessKindRo AccessKind = "RO"
	AccessKindRw AccessKind = "RW"
)

var AllAccessKind = []AccessKind{
	AccessKindRo,
	AccessKindRw,
}

func (e AccessKind) IsValid() bool {
	switch e {
	case AccessKindRo, AccessKindRw:
		return true
	}
	return false
}

func (e AccessKind) String() string {
	return string(e)
}

func (e *AccessKind) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccessKind(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccessKind", str)
	}
	return nil
}

func (e AccessKind) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AccessMode string

const (
	// Read-only
	AccessModeRo AccessMode = "RO"
	// Read/write
	AccessModeRw AccessMode = "RW"
)

var AllAccessMode = []AccessMode{
	AccessModeRo,
	AccessModeRw,
}

func (e AccessMode) IsValid() bool {
	switch e {
	case AccessModeRo, AccessModeRw:
		return true
	}
	return false
}

func (e AccessMode) String() string {
	return string(e)
}

func (e *AccessMode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccessMode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccessMode", str)
	}
	return nil
}

func (e AccessMode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type AccessScope string

const (
	AccessScopeProfile      AccessScope = "PROFILE"
	AccessScopeRepositories AccessScope = "REPOSITORIES"
	AccessScopeObjects      AccessScope = "OBJECTS"
	AccessScopeACLS         AccessScope = "ACLS"
)

var AllAccessScope = []AccessScope{
	AccessScopeProfile,
	AccessScopeRepositories,
	AccessScopeObjects,
	AccessScopeACLS,
}

func (e AccessScope) IsValid() bool {
	switch e {
	case AccessScopeProfile, AccessScopeRepositories, AccessScopeObjects, AccessScopeACLS:
		return true
	}
	return false
}

func (e AccessScope) String() string {
	return string(e)
}

func (e *AccessScope) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AccessScope(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AccessScope", str)
	}
	return nil
}

func (e AccessScope) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ObjectType string

const (
	ObjectTypeCommit ObjectType = "COMMIT"
	ObjectTypeTree   ObjectType = "TREE"
	ObjectTypeBlob   ObjectType = "BLOB"
	ObjectTypeTag    ObjectType = "TAG"
)

var AllObjectType = []ObjectType{
	ObjectTypeCommit,
	ObjectTypeTree,
	ObjectTypeBlob,
	ObjectTypeTag,
}

func (e ObjectType) IsValid() bool {
	switch e {
	case ObjectTypeCommit, ObjectTypeTree, ObjectTypeBlob, ObjectTypeTag:
		return true
	}
	return false
}

func (e ObjectType) String() string {
	return string(e)
}

func (e *ObjectType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ObjectType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ObjectType", str)
	}
	return nil
}

func (e ObjectType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Visibility string

const (
	// Visible to everyone, listed on your profile
	VisibilityPublic Visibility = "PUBLIC"
	// Visible to everyone (if they know the URL), not listed on your profile
	VisibilityUnlisted Visibility = "UNLISTED"
	// Not visible to anyone except those explicitly added to the access list
	VisibilityPrivate Visibility = "PRIVATE"
)

var AllVisibility = []Visibility{
	VisibilityPublic,
	VisibilityUnlisted,
	VisibilityPrivate,
}

func (e Visibility) IsValid() bool {
	switch e {
	case VisibilityPublic, VisibilityUnlisted, VisibilityPrivate:
		return true
	}
	return false
}

func (e Visibility) String() string {
	return string(e)
}

func (e *Visibility) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Visibility(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Visibility", str)
	}
	return nil
}

func (e Visibility) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type WebhookEvent string

const (
	WebhookEventRepoCreated WebhookEvent = "REPO_CREATED"
	WebhookEventRepoUpdate  WebhookEvent = "REPO_UPDATE"
	WebhookEventRepoDeleted WebhookEvent = "REPO_DELETED"
)

var AllWebhookEvent = []WebhookEvent{
	WebhookEventRepoCreated,
	WebhookEventRepoUpdate,
	WebhookEventRepoDeleted,
}

func (e WebhookEvent) IsValid() bool {
	switch e {
	case WebhookEventRepoCreated, WebhookEventRepoUpdate, WebhookEventRepoDeleted:
		return true
	}
	return false
}

func (e WebhookEvent) String() string {
	return string(e)
}

func (e *WebhookEvent) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = WebhookEvent(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid WebhookEvent", str)
	}
	return nil
}

func (e WebhookEvent) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
